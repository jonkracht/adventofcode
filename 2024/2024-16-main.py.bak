import sys
sys.setrecursionlimit(10**6)

infile = sys.argv[1] if len(sys.argv) >= 2 else './data/16.in'

raw = open(infile).read().strip()
data = raw.split("\n")

def move(route):
    if route[-1] == finish:
        #print(f"Found a good route: {route}")
        good_routes.append(route)
        return

    # Try to move in each direction
    loc = route[-1]

    neighbors = [(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]),
                             (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)]

    for n in neighbors:
        if n not in route and data[n[0]][n[1]] != "#":
            next_route = route.copy()
            next_route.append(n)
            move(next_route)

    return

def score_moves(routes):
    """Compute score of each route"""
    scores = {}

    for i, route in enumerate(routes):
        deltas = []
        for ii in range(len(route) - 1):
            deltas.append((route[ii+1][0] - route[ii][0],
                          route[ii+1][1] - route[ii][1]))

        # Initial direction is defined to be up - if first move is not up, add a rotation.
        if deltas[0] == (0, 1):
            score = 0
        else:
            score = 1000

        for ii in range(len(deltas)):
            if deltas[ii] == deltas[ii - 1]:
                score += 1
            else:
                score += 1001

        scores[i] = (score, route)

    return scores


# Find starting and ending indices
for i, row in enumerate(data):
    for ii, val in enumerate(row):
        if val == "S":
            start = (i, ii)
        elif val == "E":
            finish = (i, ii)

good_routes = []
route = [start]

'''
move(route)

print(f"\n{len(good_routes)} routes found through maze.")

scores = score_moves(good_routes)

best_routes, best_score = [], 1e6
for key, val in scores.items():
    #print(f"{key}: length {len(val[1])}, score {val[0]}")
    #print(val[1])

    if val[0] == best_score:
        best_routes.append(val[1])
    elif val[0] < best_score:
        best_score = val[0]
        best_routes = [val[1]]


print(f"\n{len(best_routes)} routes have lowest score of {best_score}.")
[print(b) for b in best_routes]

'''


# Implement Dijkstra's algorithm using Wikipedia pseudocode

def Dijkstra(vertices, start):
    '''Implement Dijkstra's algorithm with modifications for turns'''

    data = set() # tuples:  location, direction, score, previous_location
    for v in vertices:
        data.add((v, '', 1e8, ''))

    data.add((start, (0, 1), 0, ''))

    Q = data.copy()

    while len(Q) > 0:
        # Find point in Q that has shortest distance (begins at "start" point)
        min_distance = 1e8
        for q in Q:
            if q[2] < min_distance:
                min_distance = q[2]
                nearest = q

        Q.remove(nearest)

        # Search Q for neighbors
        for q in Q.copy():
            distance = (nearest[0][0] - q[0][0], nearest[0][1] - q[0][1])
            if distance in [(0, 1), (0, -1), (1, 0), (-1, 0)]:

                # Compute score for move
                if distance == nearest[1]:
                    alt = nearest[2] + 1
                else:
                    alt = nearest[2] + 1001

                if alt == q[2]:
                    Q.add((q[0], distance, q[2], q[3]))

                elif alt < q[2]:
kj                    q[2] = alt

    return data









'''

    score, previous_loc = {}, {}

    for v in vertices:
        score[v] = [1e8, '']
        previous_loc[v] = ''

    score[start] = [0, (0, 1)]
    Q = score.copy()

    while len(Q) > 0:
        # Find vertex with smallest distance (i.e. value of 'dist'); will begin at 'start' location and proceed outwards
        u = min(Q, key=Q.get)
        direction = Q[u][1]
        add_back = []

        #print(f"Minimum distance vertex is {u} with distance {Q[u]}")
        Q.pop(u)

        # Find neighbors of 'u'
        for q, q_attribs in Q.items():
            distance = (q[0] - u[0], q[1] - u[1])
            if distance in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                #print(key)

                # Increment score by one if move in same direction and 1001 if turning
                if distance == direction:
                    alt = score[u][0] + 1
                else:
                    alt = score[u][0] + 1001

                if alt == score[q][0]:
                    print("Found parallel path.")
                    add_back.append((q, alt, direction))

                elif alt < score[q][0]:
                    Q[q] = [alt, distance]
                    score[q] = [alt, distance]
                    previous_loc[q] = u

        if len(add_back) > 0:
            for a in add_back:
                Q[a[0]] = [a[1], a[2]]

        #print(dist)
    return score, previous_loc

'''
# Parse data in list of vertices, start and finish
vertices = []
for i, row in enumerate(data):
    for ii, val in enumerate(row):
        if val != "#":
            vertices.append((i, ii))
            if val == "S":
                start = (i, ii)
            elif val == "E":
                finish = (i, ii)

print(f"Input file:  '{infile}'")
print(f"Dimensions:  ({len(data)}, {len(data[0])})")
print(f"Start {start}, finish {finish}")

distances, previous = Dijkstra(vertices, start)

# Construct best route traveling from finish to start
shortest_path = []
u = finish
while u != '':
    shortest_path.append(u)
    u = previous[u]

best_score = distances[finish][0]

print(f"\nShortest path takes {len(shortest_path) - 1} steps:\n{shortest_path}")
print(f"Score for shortest path:  {best_score}")

print(f"\n{'Solution to Part 1:':<20} {best_score}")



#print(f"{'Solution to Part 2:':<20} {p2}")
