import sys

infile = sys.argv[1] if len(sys.argv)>=2 else './data/12.in2'

raw = open(infile).read().strip()

data = raw.split("\n")

print(data)


def make_regions(L: list):
    """Construct dictionary of regions."""

    R = {}

    for i in range(len(L)):
        for j in range(len(L[0])):

            val = L[i][j]

            if val in R.keys():

                adj = []
                for ii, r in enumerate(R[val]):
                    if count_neighbors(i, j, r) > 0:
                        adj.append(ii)
                
                # Handle number of adjacents differently
                if len(adj) == 0:
                    R[val].append([(i, j)])

                elif len(adj) == 1:
                    R[val][adj[0]].append((i, j))
                
                elif len(adj) == 2:
                    R[val][adj[0]].append((i, j))

                    l1 = R[val][adj[0]]
                    l2 = R[val][adj[1]]

                    R[val][adj[0]] = l1 + l2
                    R[val].pop(adj[1])
                        
                else:
                    print(f"{len(adj)}:  Impossible number of adjacents found.")
                    
            else:
                # If value does not exist in dictionary, initialize
                R[val] = []
                R[val].append([(i, j)])

    return R


def count_neighbors(i, j, l):
    """"""
    neighbors = 0

    if (i + 1, j) in l:
        neighbors += 1
    if (i - 1, j) in l:
        neighbors += 1
    if (i, j - 1) in l:
        neighbors += 1
    if (i, j + 1) in l:
        neighbors += 1

    return neighbors


def compute_price(R: dict):
    """Compute price metric"""
    
    price = 0
    
    for key, vals in R.items():
        for v in vals:
       
            perimeter = 0
            area = len(v)

            for i, j in v:
                neighbors = count_neighbors(i, j, v)
                perimeter += 4 - neighbors
        
            price += area * perimeter

    return price


# Part 1:
regions = make_regions(data.copy())

'''
# Print regions
for k, v in regions.items():
    print(f"\n{k}({len(v)}):")
    for vv in v:
        print(f"({len(vv)}) {vv}")
'''

p1 = compute_price(regions)

print(f"{'Solution to Part 1:':<20} {p1}")


# Part 2:

def find_exterior_points(L: list):
    """"""

    exterior_pts = []

    for pt in L:
        if count_neighbors(pt[0], pt[1], L) != 4:
            exterior_pts.append(pt)

    return exterior_pts


def order_points(O: list, U: list):
    """Order a list of points using recursion"""

    print(f"U is {U}")
    if len(U) == 0:
        print(f"\nORDERED! : {O}")
        final.append(O)
        return O

    else:
        # Find candidate next points for ordering
        C = []
        
        #print(f"O is {O}")
        #print(f"U is {U}")

        for i, u in enumerate(U):
            if abs(O[-1][0] - u[0]) + abs(O[-1][1] - u[1]) < 3:
                C.append(i)
        
        #print(C)

        # Iterate over candidate next points
        if len(C) > 0:
            for c in C:

                Q = O.copy()
                Q.append(U[c])
                #print(f"Modified O is {Q}")

                X = U.copy()
                X.pop(c)
                #print(f"Modified U is {X}")

                return order_points(Q, X)
        else:
            return False




def compute_sides(L: list):
    """Takes list of points making up a region and returns number of sides."""
   
    print(f"\nRegion:\n{L}")

    sides = 0
    
    # Determine which points are on the exterior of the region
    exterior_points = find_exterior_points(L)
    print(f"\nExterior:\n{exterior_points}")

    # Order exterior points
    order = []
    order.append(exterior_points[0])
    exterior_points.pop(0)
   
    final = []
    ordered_pts = order_points(order, exterior_points)
    print(f"Ordered points:  {final}")

    return sides


price2 = 0

for k, v in regions.items():
    for vv in v:
        sides = compute_sides(vv.copy())
        area = len(vv)

        price2 += sides * area

print(f"{'Solution to Part 2:':<20} {price2}")

